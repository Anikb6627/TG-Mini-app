<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>‡¶∂‡ßã‡¶≤‡ßã ‡¶ó‡ßÅ‡¶ü‡¶ø ‚Äî PlayMancerX (Demo)</title>
<style>
  :root{--bg:#faf9f7;--card:#fff;--muted:#666;--accent:#0ea5a4}
  body{font-family: "Noto Sans", Roboto, Arial, sans-serif; margin:0; padding:14px; background:var(--bg); color:#111}
  header{display:flex;justify-content:space-between;align-items:center;gap:8px}
  h1{margin:0;font-size:18px}
  .topbar{display:flex;gap:10px;align-items:center}
  .balance{background:var(--card);padding:8px 12px;border-radius:8px;box-shadow:0 1px 4px rgba(0,0,0,.06)}
  .btn{padding:8px 10px;border-radius:8px;border:1px solid #ddd;background:#fff;cursor:pointer}
  .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
  .board-card{background:var(--card);margin-top:12px;border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.06)}
  .small{font-size:13px;color:var(--muted)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:10px}
  .flex{display:flex;gap:8px;align-items:center}
  #svgWrap{width:100%;max-width:420px;margin:10px auto;display:block}
  svg{width:100%;height:auto}
  .node{cursor:pointer;transition:transform .08s}
  .node:hover{transform:scale(1.06)}
  .selected{stroke:#f59e0b; stroke-width:4}
  .tokenText{font-size:20px;pointer-events:none}
  .footer{margin-top:12px;text-align:center;color:var(--muted);font-size:13px}
  @media (max-width:420px){ .tokenText{font-size:18px} }
</style>
</head>
<body>
<header>
  <div>
    <h1>‡¶∂‡ßã‡¶≤‡ßã ‡¶ó‡ßÅ‡¶ü‡¶ø ‚Äî PlayMancerX</h1>
    <div class="small">‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ ‡¶∏‡ßç‡¶ü‡¶æ‡¶á‡¶≤ ‚Äî Demo board + Deposit/Withdraw</div>
  </div>
  <div class="topbar">
    <div class="balance">
      üí∞ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶®‡ßç‡¶∏: <strong id="bal">0</strong> ‡¶ü‡¶æ‡¶ï‡¶æ
    </div>
    <div class="flex">
      <button class="btn" id="btnDeposit">Deposit</button>
      <button class="btn" id="btnWithdraw">Withdraw</button>
    </div>
  </div>
</header>

<div class="board-card">
  <div style="text-align:center">
    <strong>‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ (‡¶∏‡¶∞‡¶≤ ‡¶°‡ßá‡¶Æ‡ßã)</strong>
    <div class="small">‡¶™‡¶æ‡¶≤‡¶æ ‡¶™‡¶æ‡¶≤‡¶æ ‡¶ó‡ßÅ‡¶ü‡¶ø ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶® / ‡¶≤‡¶æ‡¶´‡¶ø‡¶Ø‡¶º‡ßá ‡¶ñ‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ (jump capture) ‡¶ï‡¶∞‡¶≤‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶™‡¶ï‡ßç‡¶∑‡ßá‡¶∞ ‡¶ó‡ßÅ‡¶ü‡¶ø ‡¶ö‡¶≤‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§</div>
  </div>

  <div class="controls" style="justify-content:space-between">
    <div class="small">‡¶™‡¶æ‡¶≤‡¶æ: <strong id="turnText">Player 1 (‡¶≤‡¶æ‡¶≤)</strong></div>
    <div style="text-align:right">
      <button class="btn" id="btnReset">Reset Board</button>
      <button class="btn" id="btnHelp">Help</button>
    </div>
  </div>

  <!-- SVG board -->
  <div id="svgWrap">
    <svg id="boardSvg" viewBox="0 0 420 560" xmlns="http://www.w3.org/2000/svg">
      <!-- Lines and nodes will be drawn by JS -->
    </svg>
  </div>

  <div class="small" style="text-align:center;margin-top:8px">‡¶≤‡¶æ‡¶≤ = Player1, ‡¶®‡ßÄ‡¶≤ = Player2 ‚Ä¢ ‡¶°‡ßá‡¶Æ‡ßã ‡¶Æ‡ßã‡¶° ‚Äî ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶ü‡¶æ‡¶ï‡¶æ ‡¶®‡¶Ø‡¶º</div>
</div>

<div class="footer">Made for PlayMancerX ‚Ä¢ Demo only</div>

<script>
/* ================== Simple local balance (demo) ================== */
const BAL_KEY = 'pmx_demo_balance';
function getBal(){ return parseInt(localStorage.getItem(BAL_KEY) || '0'); }
function setBal(v){ localStorage.setItem(BAL_KEY, String(v)); renderBal(); }
function renderBal(){ document.getElementById('bal').textContent = getBal(); }

document.getElementById('btnDeposit').addEventListener('click', ()=>{
  const s = prompt('‡¶ï‡¶§ ‡¶ü‡¶æ‡¶ï‡¶æ Deposit ‡¶ï‡¶∞‡¶¨‡ßá‡¶®? (‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®)');
  const n = parseInt(s);
  if(!isNaN(n) && n>0){ setBal(getBal() + n); alert(n + ' ‡¶ü‡¶æ‡¶ï‡¶æ Deposit ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá (Demo).'); }
});
document.getElementById('btnWithdraw').addEventListener('click', ()=>{
  const s = prompt('‡¶ï‡¶§ ‡¶ü‡¶æ‡¶ï‡¶æ Withdraw ‡¶ï‡¶∞‡¶¨‡ßá‡¶®? (‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶Ø‡¶º ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®)');
  const n = parseInt(s);
  if(isNaN(n) || n<=0){ return; }
  if(n > getBal()){ alert('‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶®‡ßç‡¶∏ ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶®‡ßá‡¶á!'); return; }
  setBal(getBal() - n);
  alert(n + ' ‡¶ü‡¶æ‡¶ï‡¶æ Withdraw ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá (Demo).');
});
renderBal();

/* ================== Board layout (nodes + edges) ==================
   We'll create a board that visually matches the image: central 5x5 grid
   plus triangular extensions top & bottom (so overall node positions ~ 33).
   Each node has an id, x,y coords (SVG), and adjacency list of connected nodes.
   Movement allowed only along adjacency lines.
   Capture (jump): if adjacent node contains opponent and the next node in same direction exists & empty -> jump and capture.
   This keeps rules simple but faithful.
================================================================== */

const svg = document.getElementById('boardSvg');

/* Node coordinates (manual layout to resemble image). We'll assign ids 0..N-1
   Coordinates tuned for viewBox 420x560. Feel free to tweak.
*/
const nodes = [
  // Top small triangle (ids 0..4)
  {id:0, x:210, y:30},
  {id:1, x:170, y:70},
  {id:2, x:210, y:70},
  {id:3, x:250, y:70},
  {id:4, x:210, y:110},

  // Upper small connecting row (5..9)
  {id:5, x:70, y:150},
  {id:6, x:140, y:150},
  {id:7, x:210, y:150},
  {id:8, x:280, y:150},
  {id:9, x:350, y:150},

  // Middle 5x5 grid (ids 10..34) row-wise
  {id:10, x:70, y:220},{id:11, x:140, y:220},{id:12, x:210, y:220},{id:13, x:280, y:220},{id:14, x:350, y:220},
  {id:15, x:70, y:290},{id:16, x:140, y:290},{id:17, x:210, y:290},{id:18, x:280, y:290},{id:19, x:350, y:290},
  {id:20, x:70, y:360},{id:21, x:140, y:360},{id:22, x:210, y:360},{id:23, x:280, y:360},{id:24, x:350, y:360},

  // Lower small connecting row (25..29)
  {id:25, x:70, y:430},{id:26, x:140, y:430},{id:27, x:210, y:430},{id:28, x:280, y:430},{id:29, x:350, y:430},

  // Bottom small triangle (30..34)
  {id:30, x:210, y:480},
  {id:31, x:170, y:520},
  {id:32, x:210, y:520},
  {id:33, x:250, y:520},
  // Note: we used up to id 33 (34 nodes)
];

const N = nodes.length;

/* adjacency list (edges) ‚Äî should match lines in the image.
   We'll define by ids pairs (undirected). Keep it symmetric.
*/
const edgesPairs = [
  // top triangle
  [0,1],[0,2],[0,3],[1,2],[2,3],[2,4],
  // connecting top to main
  [4,7],
  [5,6],[6,7],[7,8],[8,9],
  // left vertical connections to grid
  [5,10],[6,11],[7,12],[8,13],[9,14],
  // main 5x5 grid internal edges (horizontal & vertical & diagonals for pattern)
  [10,11],[11,12],[12,13],[13,14],
  [15,16],[16,17],[17,18],[18,19],
  [20,21],[21,22],[22,23],[23,24],
  [10,15],[15,20],[11,16],[16,21],[12,17],[17,22],[13,18],[18,23],[14,19],[19,24],
  // some diagonals (to make pattern like image)
  [10,16],[11,17],[12,18],[13,19],
  [15,21],[16,22],[17,23],[18,24],
  // connection to lower row
  [25,20],[26,21],[27,22],[28,23],[29,24],
  [25,26],[26,27],[27,28],[28,29],
  // bottom triangle connection
  [27,30],[30,31],[30,32],[30,33],[31,32],[32,33]
];

// Build adjacency map
const adjacency = {};
for(const n of nodes) adjacency[n.id] = new Set();
for(const [a,b] of edgesPairs){
  adjacency[a].add(b); adjacency[b].add(a);
}

/* state: 0 empty, 1 player1(red), 2 player2(blue) */
let state = new Array(N).fill(0);

// Initialize starting positions roughly like image: top cluster red, bottom cluster blue
function initPositions(){
  state.fill(0);
  // top region red: ids 0..9 maybe
  [0,1,2,3,4,5,6,7,8,9].forEach(id=> state[id]=1);
  // bottom region blue: ids 25..33 maybe
  [25,26,27,28,29,30,31,32,33].forEach(id=> state[id]=2);
  // central rows remain empty for movement
}

/* Render board: draw edges & nodes & tokens */
function renderBoard(){
  svg.innerHTML = ''; // clear
  // draw edges (lines)
  for(const [a,b] of edgesPairs){
    const na = nodes.find(x=>x.id===a), nb = nodes.find(x=>x.id===b);
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('x1', na.x); line.setAttribute('y1', na.y);
    line.setAttribute('x2', nb.x); line.setAttribute('y2', nb.y);
    line.setAttribute('stroke','#7c3aed'); line.setAttribute('stroke-width','2');
    line.setAttribute('stroke-linecap','round'); svg.appendChild(line);
  }
  // draw nodes (circles) on top
  for(const n of nodes){
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${n.x},${n.y})`);
    g.classList.add('node');
    g.dataset.id = n.id;
    // circle
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('r', 16);
    c.setAttribute('fill','#fff');
    c.setAttribute('stroke','#cfcfcf');
    c.setAttribute('stroke-width','3');
    g.appendChild(c);
    // token (text or small circle)
    const val = state[n.id];
    if(val === 1){
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('r',10); circ.setAttribute('fill','#ef4444'); circ.setAttribute('cx',0); circ.setAttribute('cy',0);
      g.appendChild(circ);
    } else if(val === 2){
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('r',10); circ.setAttribute('fill','#2563eb'); circ.setAttribute('cx',0); circ.setAttribute('cy',0);
      g.appendChild(circ);
    }
    // attach text for accessibility (not visible)
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('y',6); t.setAttribute('class','tokenText'); t.setAttribute('text-anchor','middle');
    t.textContent = val===0 ? '' : (val===1 ? '‚óè' : '‚óè');
    t.style.pointerEvents = 'none';
    g.appendChild(t);

    // click handler
    g.addEventListener('click', onNodeClick);
    svg.appendChild(g);
  }
  // draw overlay selected if any
  highlightSelection();
}

/* Selection and move logic */
let selected = null; // selected node id (player choosing their piece)
let currentPlayer = 1; // 1 red, 2 blue
const turnText = document.getElementById('turnText');

function updateTurnText(){ turnText.textContent = currentPlayer===1 ? 'Player 1 (‡¶≤‡¶æ‡¶≤)' : 'Player 2 (‡¶®‡ßÄ‡¶≤)'; }

function onNodeClick(e){
  const id = parseInt(e.currentTarget.dataset.id);
  // if selecting own piece
  if(state[id] === currentPlayer){
    selected = id;
    highlightSelection();
    return;
  }
  // else if empty and we have selection -> try move or jump
  if(state[id] === 0 && selected !== null){
    const ok = tryMove(selected, id);
    if(ok){
      selected = null;
      renderBoard();
    } else {
      // not a valid move
      alert('‡¶∏‡¶†‡¶ø‡¶ï ‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶®‡ßü - ‡¶Ü‡¶™‡¶®‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ò‡¶∞‡ßá ‡¶∏‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶® ‡¶¨‡¶æ ‡¶≤‡¶æ‡¶´ ‡¶¶‡¶ø‡ßü‡ßá ‡¶ï‡ßç‡¶Ø‡¶æ‡¶™‡¶ö‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶®‡•§');
    }
  }
}

/* Try move from fromId to toId:
   - If toId is adjacent (in adjacency[from]) and empty -> simple move
   - Else if toId is exactly two steps in same direction: there exists mid node (adjacent to from and adjacent to to) such that mid occupied by opponent and to empty -> perform jump capture
*/
function tryMove(fromId, toId){
  // adjacency
  if(adjacency[fromId].has(toId)){
    // simple adjacent move (only allow moving into empty)
    if(state[toId] === 0){
      state[toId] = state[fromId]; state[fromId] = 0;
      switchPlayer();
      return true;
    }
    return false;
  }
  // try jump: find a mid node that is neighbor to both fromId and toId
  for(const mid of adjacency[fromId]){
    if(adjacency[mid].has(toId)){
      // mid is between from and to
      if(state[mid] === (currentPlayer===1?2:1) && state[toId] === 0){
        // perform capture
        state[toId] = state[fromId];
        state[fromId] = 0;
        state[mid] = 0; // remove opponent
        switchPlayer();
        return true;
      }
    }
  }
  return false;
}

function switchPlayer(){
  currentPlayer = currentPlayer===1 ? 2 : 1;
  updateTurnText();
}

/* visual highlight of selected node */
function highlightSelection(){
  // clear previous styles
  const groups = svg.querySelectorAll('g.node');
  groups.forEach(g=>{
    g.querySelector('circle').classList.remove('selected');
    const id = parseInt(g.dataset.id);
    g.querySelector('circle').setAttribute('stroke','#cfcfcf');
    g.querySelector('circle').setAttribute('stroke-width','3');
  });
  if(selected !== null){
    const g = svg.querySelector(`g.node[data-id="${selected}"]`);
    if(g){
      const circ = g.querySelector('circle');
      circ.setAttribute('stroke','#f59e0b');
      circ.setAttribute('stroke-width','4');
    }
  }
}

/* Reset & help */
document.getElementById('btnReset').addEventListener('click', ()=>{
  if(confirm('‡¶¨‡¶æ‡¶∞‡¶¨‡¶æ‡¶∞ Reset ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ñ‡ßá‡¶≤‡¶æ ‡¶∞‡¶ø‡¶∏‡ßá‡¶ü ‡¶π‡¶¨‡ßá ‚Äî ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§?')){ initPositions(); renderBoard(); currentPlayer=1; updateTurnText(); selected=null; }
});
document.getElementById('btnHelp').addEventListener('click', ()=>{
  alert('‡¶®‡¶ø‡¶Ø‡¶º‡¶Æ (‡¶∏‡¶∞‡¶≤ ‡¶°‡ßá‡¶Æ‡ßã):\n\n- ‡¶™‡¶æ‡¶≤‡¶æ ‡¶™‡¶æ‡¶≤‡¶æ ‡¶ó‡ßÅ‡¶ü‡¶ø ‡¶∏‡¶∞‡¶æ‡¶®‡•§\n- ‡¶Ø‡¶¶‡¶ø ‡¶™‡¶æ‡¶∂‡ßá‡¶∞ ‡¶ò‡¶∞‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶™‡¶ï‡ßç‡¶∑ ‡¶•‡¶æ‡¶ï‡ßá ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶∞ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶™‡¶∞‡ßá‡¶∞ ‡¶ò‡¶∞ ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶•‡¶æ‡¶ï‡ßá, ‡¶Ü‡¶™‡¶®‡¶ø ‡¶≤‡¶æ‡¶´ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá (jump) ‡¶§‡¶æ‡¶∞ ‡¶ó‡ßÅ‡¶ü‡¶ø ‡¶ñ‡ßá‡¶≤‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶® (capture)‡•§\n- ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶ö‡¶≤‡¶® ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶∏‡¶Ç‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶®‡ßã‡¶°‡¶ó‡ßÅ‡¶≤‡ßã‡¶§‡ßá‡•§\n\n(‡¶è‡¶á ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶∞‡¶≤ ‡¶°‡ßá‡¶Æ‡ßã; ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ü‡ßÅ‡¶∞‡ßç‡¶®-‡¶¨‡ßá‡¶∏‡¶°/‡¶Æ‡¶æ‡¶≤‡ßç‡¶ü‡¶ø‡¶™‡ßç‡¶≤‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶®‡ßü)‡•§');
});

/* initialize */
initPositions(); renderBoard(); updateTurnText();

/* make board clickable when window resizes (in case) */
window.addEventListener('resize', ()=> renderBoard());
</script>
</body>
</html>
